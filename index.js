/*
 * This file is part of ncSender.
 *
 * ncSender is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * ncSender is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with ncSender. If not, see <https://www.gnu.org/licenses/>.
 */

/**
 * 3DMesh Plugin
 * Surface mesh probing with Z compensation for milling curved materials
 */

import fs from 'node:fs/promises';
import path from 'node:path';
import os from 'node:os';

function getUserDataDir() {
  const platform = os.platform();
  const appName = 'ncSender';
  switch (platform) {
    case 'win32':
      return path.join(os.homedir(), 'AppData', 'Roaming', appName);
    case 'darwin':
      return path.join(os.homedir(), 'Library', 'Application Support', appName);
    case 'linux':
      return path.join(os.homedir(), '.config', appName);
    default:
      return path.join(os.homedir(), `.${appName}`);
  }
}

function getMeshFilePath() {
  return path.join(getUserDataDir(), 'plugin-config', 'com.ncsender.3dmesh', 'mesh.json');
}

// In-memory mesh storage
let currentMesh = null;
let meshGridParams = null;

// Analyze G-code to get bounding box
function analyzeGCodeBounds(gcodeContent) {
  const bounds = {
    min: { x: Infinity, y: Infinity, z: Infinity },
    max: { x: -Infinity, y: -Infinity, z: -Infinity }
  };

  let currentX = 0, currentY = 0, currentZ = 0;
  let isAbsolute = true;

  const lines = gcodeContent.split('\n');

  for (const line of lines) {
    const trimmed = line.trim().toUpperCase();

    if (trimmed.startsWith('(') || trimmed.startsWith(';') || trimmed.startsWith('%')) {
      continue;
    }

    if (trimmed.includes('G90') && !trimmed.includes('G90.1')) isAbsolute = true;
    if (trimmed.includes('G91') && !trimmed.includes('G91.1')) isAbsolute = false;

    if (trimmed.includes('G53')) continue;

    const xMatch = trimmed.match(/X([+-]?\d*\.?\d+)/);
    const yMatch = trimmed.match(/Y([+-]?\d*\.?\d+)/);
    const zMatch = trimmed.match(/Z([+-]?\d*\.?\d+)/);

    if (xMatch) {
      const val = parseFloat(xMatch[1]);
      currentX = isAbsolute ? val : currentX + val;
    }
    if (yMatch) {
      const val = parseFloat(yMatch[1]);
      currentY = isAbsolute ? val : currentY + val;
    }
    if (zMatch) {
      const val = parseFloat(zMatch[1]);
      currentZ = isAbsolute ? val : currentZ + val;
    }

    if (xMatch || yMatch || zMatch) {
      bounds.min.x = Math.min(bounds.min.x, currentX);
      bounds.min.y = Math.min(bounds.min.y, currentY);
      bounds.min.z = Math.min(bounds.min.z, currentZ);
      bounds.max.x = Math.max(bounds.max.x, currentX);
      bounds.max.y = Math.max(bounds.max.y, currentY);
      bounds.max.z = Math.max(bounds.max.z, currentZ);
    }
  }

  if (bounds.min.x === Infinity) bounds.min.x = 0;
  if (bounds.min.y === Infinity) bounds.min.y = 0;
  if (bounds.min.z === Infinity) bounds.min.z = 0;
  if (bounds.max.x === -Infinity) bounds.max.x = 0;
  if (bounds.max.y === -Infinity) bounds.max.y = 0;
  if (bounds.max.z === -Infinity) bounds.max.z = 0;

  return bounds;
}

// Bilinear interpolation for Z lookup
function interpolateZ(x, y, mesh, gridParams) {
  const { startX, startY, spacingX, spacingY, rows, cols } = gridParams;

  const colFloat = (x - startX) / spacingX;
  const rowFloat = (y - startY) / spacingY;

  const col = Math.max(0, Math.min(cols - 2, Math.floor(colFloat)));
  const row = Math.max(0, Math.min(rows - 2, Math.floor(rowFloat)));

  const z00 = mesh[row][col]?.z ?? 0;
  const z10 = mesh[row][col + 1]?.z ?? z00;
  const z01 = mesh[row + 1]?.[col]?.z ?? z00;
  const z11 = mesh[row + 1]?.[col + 1]?.z ?? z00;

  const tx = Math.max(0, Math.min(1, colFloat - col));
  const ty = Math.max(0, Math.min(1, rowFloat - row));

  return z00 * (1 - tx) * (1 - ty) + z10 * tx * (1 - ty) + z01 * (1 - tx) * ty + z11 * tx * ty;
}

// Apply Z compensation to G-code
function applyZCompensation(gcodeContent, mesh, gridParams, referenceZ) {
  const lines = gcodeContent.split('\n');
  const output = [];

  let currentX = 0, currentY = 0;
  let isAbsolute = true;

  output.push('(Z-Compensated G-code generated by 3DMesh Plugin)');
  output.push(`(Grid: ${gridParams.cols} x ${gridParams.rows} points)`);
  output.push(`(Reference Z: ${referenceZ.toFixed(3)})`);
  output.push('');

  for (const line of lines) {
    const trimmed = line.trim().toUpperCase();

    if (!trimmed || trimmed.startsWith('(') || trimmed.startsWith(';') || trimmed.startsWith('%')) {
      output.push(line);
      continue;
    }

    if (trimmed.includes('G90') && !trimmed.includes('G90.1')) isAbsolute = true;
    if (trimmed.includes('G91') && !trimmed.includes('G91.1')) isAbsolute = false;

    if (trimmed.includes('G53')) {
      output.push(line);
      continue;
    }

    const xMatch = line.match(/X([+-]?\d*\.?\d+)/i);
    const yMatch = line.match(/Y([+-]?\d*\.?\d+)/i);
    const zMatch = line.match(/Z([+-]?\d*\.?\d+)/i);

    if (xMatch) {
      const val = parseFloat(xMatch[1]);
      currentX = isAbsolute ? val : currentX + val;
    }
    if (yMatch) {
      const val = parseFloat(yMatch[1]);
      currentY = isAbsolute ? val : currentY + val;
    }

    if (zMatch && isAbsolute) {
      const originalZ = parseFloat(zMatch[1]);
      const meshZ = interpolateZ(currentX, currentY, mesh, gridParams);
      const zOffset = meshZ - referenceZ;
      const compensatedZ = originalZ + zOffset;

      const newLine = line.replace(/Z([+-]?\d*\.?\d+)/i, `Z${compensatedZ.toFixed(3)}`);
      output.push(newLine);
    } else {
      output.push(line);
    }
  }

  return output.join('\n');
}

// Save mesh to file
async function saveMeshToFile(mesh, gridParams) {
  const filePath = getMeshFilePath();
  const dir = path.dirname(filePath);

  await fs.mkdir(dir, { recursive: true });

  const data = {
    version: 1,
    timestamp: new Date().toISOString(),
    gridParams,
    mesh
  };

  await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf8');
  return filePath;
}

// Load mesh from file
async function loadMeshFromFile() {
  const filePath = getMeshFilePath();

  const content = await fs.readFile(filePath, 'utf8');
  const data = JSON.parse(content);

  return {
    mesh: data.mesh,
    gridParams: data.gridParams
  };
}

export async function onLoad(ctx) {
  ctx.log('3DMesh plugin loaded');

  // Try to load saved mesh on startup
  try {
    const { mesh, gridParams } = await loadMeshFromFile();
    currentMesh = mesh;
    meshGridParams = gridParams;
    ctx.log('Loaded saved mesh:', gridParams.cols, 'x', gridParams.rows);
  } catch (error) {
    // No saved mesh, that's fine
  }

  ctx.registerToolMenu('3DMesh', async () => {
    ctx.log('3DMesh tool clicked');

    const savedSettings = ctx.getSettings() || {};
    const settings = {
      gridMode: savedSettings.gridMode || 'manual',
      rows: savedSettings.rows ?? 5,
      cols: savedSettings.cols ?? 5,
      startX: savedSettings.startX ?? 0,
      startY: savedSettings.startY ?? 0,
      endX: savedSettings.endX ?? 100,
      endY: savedSettings.endY ?? 100,
      probeFeedRate: savedSettings.probeFeedRate ?? 100,
      retractHeight: savedSettings.retractHeight ?? 5,
      maxPlunge: savedSettings.maxPlunge ?? 20,
      referenceZ: savedSettings.referenceZ ?? 0
    };

    const appSettings = ctx.getAppSettings();
    const unitsPreference = appSettings.unitsPreference || 'metric';
    const isImperial = unitsPreference === 'imperial';
    const distanceUnit = isImperial ? 'in' : 'mm';
    const feedUnit = isImperial ? 'in/min' : 'mm/min';

    const serverState = ctx.getServerState();
    const jobLoaded = serverState?.jobLoaded;
    const hasGcode = !!jobLoaded?.filename;

    let gcodeBounds = null;
    if (hasGcode) {
      try {
        const cacheFilePath = path.join(getUserDataDir(), 'gcode-cache', 'current.gcode');
        const gcodeContent = await fs.readFile(cacheFilePath, 'utf8');
        gcodeBounds = analyzeGCodeBounds(gcodeContent);
      } catch (error) {
        ctx.log('Failed to analyze G-code bounds:', error);
      }
    }

    const hasMesh = currentMesh !== null && meshGridParams !== null;

    // Serialize mesh data for client
    const meshDataJson = hasMesh ? JSON.stringify({ mesh: currentMesh, gridParams: meshGridParams }) : 'null';

    showMainDialog(ctx, {
      settings,
      isImperial,
      distanceUnit,
      feedUnit,
      hasGcode,
      gcodeBounds,
      hasMesh,
      meshDataJson,
      filename: jobLoaded?.filename
    });
  }, { icon: 'logo.png' });

  // Listen for mesh updates from client
  ctx.onWebSocketEvent('plugin:3dmesh:save-mesh', async (data) => {
    if (data && data.mesh && data.gridParams) {
      currentMesh = data.mesh;
      meshGridParams = data.gridParams;
      try {
        await saveMeshToFile(currentMesh, meshGridParams);
        ctx.log('Mesh saved to file');
      } catch (error) {
        ctx.log('Failed to save mesh:', error);
      }
    }
  });

  // Listen for apply compensation requests
  ctx.onWebSocketEvent('plugin:3dmesh:apply-compensation', async (data) => {
    if (!currentMesh || !meshGridParams) {
      ctx.broadcast('plugin:3dmesh:compensation-result', { success: false, error: 'No mesh data' });
      return;
    }

    try {
      const cacheFilePath = path.join(getUserDataDir(), 'gcode-cache', 'current.gcode');
      const gcodeContent = await fs.readFile(cacheFilePath, 'utf8');

      const referenceZ = data.referenceZ ?? 0;
      const compensatedGcode = applyZCompensation(gcodeContent, currentMesh, meshGridParams, referenceZ);

      const serverState = ctx.getServerState();
      const originalFilename = serverState?.jobLoaded?.filename || 'program.nc';
      const outputFilename = originalFilename.replace(/\.[^.]+$/, '') + '_compensated.nc';

      // Load the compensated G-code via API
      const response = await fetch('http://localhost:8090/api/gcode-files/load-temp', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          content: compensatedGcode,
          filename: outputFilename,
          sourceFile: originalFilename
        })
      });

      if (response.ok) {
        ctx.broadcast('plugin:3dmesh:compensation-result', { success: true, filename: outputFilename });
      } else {
        ctx.broadcast('plugin:3dmesh:compensation-result', { success: false, error: 'Failed to load compensated file' });
      }
    } catch (error) {
      ctx.log('Apply compensation error:', error);
      ctx.broadcast('plugin:3dmesh:compensation-result', { success: false, error: error.message });
    }
  });
}

function showMainDialog(ctx, params) {
  const {
    settings,
    isImperial,
    distanceUnit,
    feedUnit,
    hasGcode,
    gcodeBounds,
    hasMesh,
    meshDataJson,
    filename
  } = params;

  const MM_TO_INCH = 0.0393701;
  const convertToDisplay = (value) => isImperial ? parseFloat((value * MM_TO_INCH).toFixed(3)) : value;

  const boundsInfo = gcodeBounds
    ? `X: ${convertToDisplay(gcodeBounds.min.x).toFixed(1)} to ${convertToDisplay(gcodeBounds.max.x).toFixed(1)}, Y: ${convertToDisplay(gcodeBounds.min.y).toFixed(1)} to ${convertToDisplay(gcodeBounds.max.y).toFixed(1)}`
    : 'No G-code loaded';

  const gcodeBoundsJson = gcodeBounds ? JSON.stringify(gcodeBounds) : 'null';

  ctx.showDialog(
    '3DMesh - Surface Probing',
    /* html */ `
    <style>
      .mesh-dialog { padding: 20px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; color: var(--color-text-primary); max-width: 700px; }
      .mesh-tabs { display: flex; border-bottom: 1px solid var(--color-border); margin-bottom: 20px; }
      .mesh-tab { padding: 10px 20px; cursor: pointer; border: none; background: none; color: var(--color-text-secondary); font-size: 0.95rem; font-weight: 500; border-bottom: 2px solid transparent; margin-bottom: -1px; }
      .mesh-tab.active { color: var(--color-accent); border-bottom-color: var(--color-accent); }
      .mesh-tab:hover:not(.active) { color: var(--color-text-primary); }
      .mesh-panel { display: none; }
      .mesh-panel.active { display: block; }
      .form-section { background: var(--color-surface-muted); border: 1px solid var(--color-border); border-radius: 8px; padding: 16px; margin-bottom: 16px; }
      .form-section-title { font-weight: 600; margin-bottom: 12px; color: var(--color-text-primary); }
      .form-row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 16px; margin-bottom: 12px; }
      .form-row.three-col { grid-template-columns: repeat(3, 1fr); }
      .form-group { display: flex; flex-direction: column; }
      .form-group label { font-size: 0.85rem; font-weight: 500; margin-bottom: 4px; color: var(--color-text-primary); }
      .form-group input, .form-group select { padding: 8px 10px; border: 1px solid var(--color-border); border-radius: 4px; font-size: 0.9rem; background: var(--color-surface); color: var(--color-text-primary); }
      .form-group input:focus, .form-group select:focus { outline: none; border-color: var(--color-accent); }
      .info-box { background: var(--color-surface-muted); border: 1px solid var(--color-border); border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; font-size: 0.9rem; }
      .info-box.success { border-color: #4caf50; background: rgba(76, 175, 80, 0.1); }
      .info-box.warning { border-color: #ff9800; background: rgba(255, 152, 0, 0.1); }
      .mesh-status { display: flex; align-items: center; gap: 8px; }
      .status-dot { width: 10px; height: 10px; border-radius: 50%; background: #666; }
      .status-dot.active { background: #4caf50; }
      .button-row { display: flex; justify-content: center; gap: 10px; margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--color-border); }
      .btn { padding: 10px 24px; border-radius: 4px; font-size: 0.9rem; font-weight: 500; cursor: pointer; transition: background-color 0.2s; border: none; }
      .btn-secondary { background: var(--color-surface); border: 1px solid var(--color-border); color: var(--color-text-primary); }
      .btn-secondary:hover { background: var(--color-surface-muted); }
      .btn-primary { background: var(--color-accent); color: white; }
      .btn-primary:hover { opacity: 0.9; }
      .btn-primary:disabled, .btn-success:disabled { opacity: 0.5; cursor: not-allowed; }
      .btn-success { background: #4caf50; color: white; }
      .btn-danger { background: #f44336; color: white; }
      .probe-progress { border: 1px solid var(--color-border); border-radius: 4px; padding: 16px; background: var(--color-surface); min-height: 120px; }
      .progress-bar { height: 8px; background: var(--color-surface-muted); border-radius: 4px; overflow: hidden; margin: 10px 0; }
      .progress-fill { height: 100%; background: var(--color-accent); transition: width 0.3s; }
      .mesh-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
      .mesh-table th, .mesh-table td { padding: 4px 8px; border: 1px solid var(--color-border); text-align: center; }
      .mesh-table th { background: var(--color-surface-muted); }
    </style>

    <div class="mesh-dialog">
      <div class="mesh-tabs">
        <button class="mesh-tab active" data-tab="setup">Setup</button>
        <button class="mesh-tab" data-tab="probe">Probe</button>
        <button class="mesh-tab" data-tab="mesh">Mesh Data</button>
        <button class="mesh-tab" data-tab="apply">Apply</button>
      </div>

      <!-- Setup Tab -->
      <div class="mesh-panel active" id="panel-setup">
        <div class="form-section">
          <div class="form-section-title">Grid Configuration</div>
          <div class="form-row">
            <div class="form-group">
              <label>Grid Mode</label>
              <select id="gridMode">
                <option value="manual" ${settings.gridMode === 'manual' ? 'selected' : ''}>Manual</option>
                <option value="auto" ${settings.gridMode === 'auto' ? 'selected' : ''} ${!hasGcode ? 'disabled' : ''}>Auto from G-code</option>
              </select>
            </div>
            <div class="form-group">
              <label>Grid Size</label>
              <div style="display: flex; gap: 8px; align-items: center;">
                <input type="number" id="cols" value="${settings.cols}" min="2" max="50" style="width: 60px;">
                <span>x</span>
                <input type="number" id="rows" value="${settings.rows}" min="2" max="50" style="width: 60px;">
                <span>points</span>
              </div>
            </div>
          </div>
          <div id="manualGridSettings">
            <div class="form-row">
              <div class="form-group">
                <label>Start X (${distanceUnit})</label>
                <input type="number" id="startX" value="${convertToDisplay(settings.startX)}" step="0.1">
              </div>
              <div class="form-group">
                <label>End X (${distanceUnit})</label>
                <input type="number" id="endX" value="${convertToDisplay(settings.endX)}" step="0.1">
              </div>
            </div>
            <div class="form-row">
              <div class="form-group">
                <label>Start Y (${distanceUnit})</label>
                <input type="number" id="startY" value="${convertToDisplay(settings.startY)}" step="0.1">
              </div>
              <div class="form-group">
                <label>End Y (${distanceUnit})</label>
                <input type="number" id="endY" value="${convertToDisplay(settings.endY)}" step="0.1">
              </div>
            </div>
          </div>
          <div id="autoGridInfo" style="display: ${settings.gridMode === 'auto' ? 'block' : 'none'};">
            <div class="info-box"><strong>G-code Bounds:</strong> ${boundsInfo}</div>
          </div>
        </div>

        <div class="form-section">
          <div class="form-section-title">Probe Settings</div>
          <div class="form-row three-col">
            <div class="form-group">
              <label>Probe Feed Rate (${feedUnit})</label>
              <input type="number" id="probeFeedRate" value="${settings.probeFeedRate}" min="1" max="1000">
            </div>
            <div class="form-group">
              <label>Retract Height (${distanceUnit})</label>
              <input type="number" id="retractHeight" value="${convertToDisplay(settings.retractHeight)}" min="0.1" step="0.1">
            </div>
            <div class="form-group">
              <label>Max Plunge (${distanceUnit})</label>
              <input type="number" id="maxPlunge" value="${convertToDisplay(settings.maxPlunge)}" min="1" step="0.1">
            </div>
          </div>
        </div>

        <div class="info-box" id="meshStatusBox">
          <div class="mesh-status">
            <div class="status-dot" id="meshStatusDot"></div>
            <span id="meshStatusText">Checking mesh status...</span>
          </div>
        </div>
      </div>

      <!-- Probe Tab -->
      <div class="mesh-panel" id="panel-probe">
        <div class="info-box warning">
          <strong>Before Probing:</strong>
          <ul style="margin: 8px 0 0 20px; padding: 0;">
            <li>Ensure probe is connected and working</li>
            <li>Position spindle at the starting corner above the work</li>
            <li>Current position will be used as the probe start point</li>
          </ul>
        </div>

        <div class="form-section">
          <div class="form-section-title">Probe Progress</div>
          <div class="probe-progress" id="probeProgress">
            <div id="probeStatus">Click "Start Probing" to begin mesh probing sequence</div>
            <div class="progress-bar" style="display: none;" id="progressBarContainer">
              <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
            <div id="probeStats" style="margin-top: 10px; font-size: 0.85rem; color: var(--color-text-secondary);"></div>
          </div>
        </div>

        <div class="button-row" style="border: none; margin-top: 0;">
          <button class="btn btn-primary" id="startProbeBtn">Start Probing</button>
          <button class="btn btn-danger" id="stopProbeBtn" style="display: none;">Stop</button>
        </div>
      </div>

      <!-- Mesh Data Tab -->
      <div class="mesh-panel" id="panel-mesh">
        <div class="form-section">
          <div class="form-section-title">Mesh Data</div>
          <div id="meshDataDisplay" style="max-height: 300px; overflow: auto;">
            <p style="text-align: center; color: var(--color-text-secondary);">No mesh data available</p>
          </div>
        </div>

        <div id="meshStatsDisplay" class="info-box" style="display: none;"></div>

        <div class="button-row" style="border: none; margin-top: 0;">
          <button class="btn btn-secondary" id="saveMeshBtn" disabled>Save to File</button>
          <button class="btn btn-secondary" id="loadMeshBtn">Load from File</button>
          <button class="btn btn-secondary" id="clearMeshBtn" disabled>Clear</button>
        </div>
      </div>

      <!-- Apply Tab -->
      <div class="mesh-panel" id="panel-apply">
        <div class="info-box" id="applyStatusBox">
          <span id="applyStatusText">Checking requirements...</span>
        </div>

        <div class="form-section">
          <div class="form-section-title">Compensation Settings</div>
          <div class="form-row">
            <div class="form-group">
              <label>Reference Z (${distanceUnit})</label>
              <input type="number" id="referenceZ" value="${convertToDisplay(settings.referenceZ)}" step="0.001">
            </div>
            <div class="form-group">
              <label>Source File</label>
              <input type="text" value="${filename || 'No file loaded'}" disabled>
            </div>
          </div>
        </div>

        <div class="button-row" style="border: none; margin-top: 0;">
          <button class="btn btn-success" id="applyCompensationBtn" disabled>Apply Z Compensation</button>
        </div>
      </div>

      <div class="button-row">
        <button class="btn btn-secondary" onclick="window.postMessage({ type: 'close-plugin-dialog' }, '*')">Close</button>
        <button class="btn btn-primary" id="saveSettingsBtn">Save Settings</button>
      </div>
    </div>

    <script>
      (function() {
        const isImperial = ${isImperial};
        const INCH_TO_MM = 25.4;
        const MM_TO_INCH = 0.0393701;
        const hasGcode = ${hasGcode};
        const gcodeBounds = ${gcodeBoundsJson};
        const convertToMetric = (value) => isImperial ? value * INCH_TO_MM : value;
        const convertToDisplay = (value) => isImperial ? value * MM_TO_INCH : value;

        // Calculate API base URL (handle Vite dev server on port 5174)
        function getApiBaseUrl() {
          if (typeof window !== 'undefined' && window.location) {
            if (window.location.port === '5174') {
              return 'http://' + window.location.hostname + ':8090';
            }
            return window.location.protocol + '//' + window.location.host;
          }
          return '';
        }
        const API_BASE = getApiBaseUrl();

        // Mesh state
        let meshData = ${meshDataJson};
        let isProbing = false;
        let stopProbing = false;

        // Update UI based on mesh state
        function updateMeshStatus() {
          const hasMesh = meshData && meshData.mesh && meshData.gridParams;
          const statusDot = document.getElementById('meshStatusDot');
          const statusText = document.getElementById('meshStatusText');
          const statusBox = document.getElementById('meshStatusBox');

          if (hasMesh) {
            statusDot.classList.add('active');
            statusText.textContent = 'Mesh data loaded (' + meshData.gridParams.cols + 'x' + meshData.gridParams.rows + ' points)';
            statusBox.classList.add('success');
            document.getElementById('saveMeshBtn').disabled = false;
            document.getElementById('clearMeshBtn').disabled = false;
          } else {
            statusDot.classList.remove('active');
            statusText.textContent = 'No mesh data - run probing first';
            statusBox.classList.remove('success');
            document.getElementById('saveMeshBtn').disabled = true;
            document.getElementById('clearMeshBtn').disabled = true;
          }

          updateApplyStatus();
          updateMeshDisplay();
        }

        function updateApplyStatus() {
          const hasMesh = meshData && meshData.mesh && meshData.gridParams;
          const statusBox = document.getElementById('applyStatusBox');
          const statusText = document.getElementById('applyStatusText');
          const applyBtn = document.getElementById('applyCompensationBtn');

          if (hasGcode && hasMesh) {
            statusBox.classList.remove('warning');
            statusBox.classList.add('success');
            statusText.innerHTML = '<strong>Ready to apply:</strong> Mesh data and G-code loaded';
            applyBtn.disabled = false;
          } else {
            statusBox.classList.remove('success');
            statusBox.classList.add('warning');
            statusText.innerHTML = '<strong>Requirements:</strong> ' +
              (!hasGcode ? 'Load a G-code file' : '') +
              (!hasGcode && !hasMesh ? ' and ' : '') +
              (!hasMesh ? 'Run probing first' : '');
            applyBtn.disabled = true;
          }
        }

        function updateMeshDisplay() {
          const container = document.getElementById('meshDataDisplay');
          const statsDisplay = document.getElementById('meshStatsDisplay');

          if (!meshData || !meshData.mesh || !meshData.gridParams) {
            container.innerHTML = '<p style="text-align: center; color: var(--color-text-secondary);">No mesh data available</p>';
            statsDisplay.style.display = 'none';
            return;
          }

          const { mesh, gridParams } = meshData;

          // Calculate stats
          let minZ = Infinity, maxZ = -Infinity, sum = 0, count = 0;
          for (const row of mesh) {
            for (const point of row) {
              if (point && typeof point.z === 'number') {
                minZ = Math.min(minZ, point.z);
                maxZ = Math.max(maxZ, point.z);
                sum += point.z;
                count++;
              }
            }
          }
          const avgZ = count > 0 ? sum / count : 0;
          const range = maxZ - minZ;

          statsDisplay.innerHTML =
            '<strong>Statistics:</strong> ' +
            'Min Z: ' + convertToDisplay(minZ).toFixed(3) + ' | ' +
            'Max Z: ' + convertToDisplay(maxZ).toFixed(3) + ' | ' +
            'Range: ' + convertToDisplay(range).toFixed(3) + ' | ' +
            'Avg: ' + convertToDisplay(avgZ).toFixed(3);
          statsDisplay.style.display = 'block';

          // Build table
          let html = '<table class="mesh-table"><thead><tr><th></th>';
          for (let c = 0; c < gridParams.cols; c++) {
            html += '<th>C' + c + '</th>';
          }
          html += '</tr></thead><tbody>';

          for (let r = mesh.length - 1; r >= 0; r--) {
            html += '<tr><th>R' + r + '</th>';
            for (let c = 0; c < gridParams.cols; c++) {
              const point = mesh[r]?.[c];
              const z = point?.z;
              html += '<td>' + (typeof z === 'number' ? convertToDisplay(z).toFixed(3) : '-') + '</td>';
            }
            html += '</tr>';
          }
          html += '</tbody></table>';

          container.innerHTML = html;
        }

        // Tab switching
        document.querySelectorAll('.mesh-tab').forEach(tab => {
          tab.addEventListener('click', () => {
            document.querySelectorAll('.mesh-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.mesh-panel').forEach(p => p.classList.remove('active'));
            tab.classList.add('active');
            document.getElementById('panel-' + tab.dataset.tab).classList.add('active');
          });
        });

        // Grid mode toggle
        document.getElementById('gridMode').addEventListener('change', (e) => {
          const isAuto = e.target.value === 'auto';
          document.getElementById('manualGridSettings').style.display = isAuto ? 'none' : 'block';
          document.getElementById('autoGridInfo').style.display = isAuto ? 'block' : 'none';

          if (isAuto && gcodeBounds) {
            document.getElementById('startX').value = convertToDisplay(gcodeBounds.min.x).toFixed(3);
            document.getElementById('endX').value = convertToDisplay(gcodeBounds.max.x).toFixed(3);
            document.getElementById('startY').value = convertToDisplay(gcodeBounds.min.y).toFixed(3);
            document.getElementById('endY').value = convertToDisplay(gcodeBounds.max.y).toFixed(3);
          }
        });

        // Save settings
        document.getElementById('saveSettingsBtn').addEventListener('click', async () => {
          const settings = {
            gridMode: document.getElementById('gridMode').value,
            rows: parseInt(document.getElementById('rows').value),
            cols: parseInt(document.getElementById('cols').value),
            startX: convertToMetric(parseFloat(document.getElementById('startX').value)),
            startY: convertToMetric(parseFloat(document.getElementById('startY').value)),
            endX: convertToMetric(parseFloat(document.getElementById('endX').value)),
            endY: convertToMetric(parseFloat(document.getElementById('endY').value)),
            probeFeedRate: parseFloat(document.getElementById('probeFeedRate').value),
            retractHeight: convertToMetric(parseFloat(document.getElementById('retractHeight').value)),
            maxPlunge: convertToMetric(parseFloat(document.getElementById('maxPlunge').value)),
            referenceZ: convertToMetric(parseFloat(document.getElementById('referenceZ').value))
          };

          try {
            await fetch(API_BASE + '/api/plugins/com.ncsender.3dmesh/settings', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(settings)
            });
            alert('Settings saved!');
          } catch (error) {
            alert('Failed to save settings');
          }
        });

        // Send CNC command helper
        async function sendCommand(command) {
          const response = await fetch(API_BASE + '/api/cnc/send-command', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              command,
              meta: { sourceId: 'plugin', plugin: 'com.ncsender.3dmesh' }
            })
          });
          return response.json();
        }

        // Wait for specific response pattern
        function waitForResponse(pattern, timeout = 10000) {
          return new Promise((resolve, reject) => {
            const timeoutId = setTimeout(() => {
              window.removeEventListener('message', handler);
              reject(new Error('Timeout waiting for response'));
            }, timeout);

            const handler = (event) => {
              if (event.data?.type === 'cnc-data') {
                const data = event.data.data;
                if (typeof data === 'string' && pattern.test(data)) {
                  clearTimeout(timeoutId);
                  window.removeEventListener('message', handler);
                  resolve(data);
                }
              }
            };

            window.addEventListener('message', handler);
          });
        }

        // Parse PRB response
        function parsePRB(response) {
          const match = response.match(/\\[PRB:([+-]?[\\d.]+),([+-]?[\\d.]+),([+-]?[\\d.]+):([01])\\]/);
          if (match) {
            return {
              x: parseFloat(match[1]),
              y: parseFloat(match[2]),
              z: parseFloat(match[3]),
              success: match[4] === '1'
            };
          }
          return null;
        }

        // Start probing
        document.getElementById('startProbeBtn').addEventListener('click', async () => {
          if (isProbing) return;

          const rows = parseInt(document.getElementById('rows').value);
          const cols = parseInt(document.getElementById('cols').value);
          const startX = convertToMetric(parseFloat(document.getElementById('startX').value));
          const startY = convertToMetric(parseFloat(document.getElementById('startY').value));
          const endX = convertToMetric(parseFloat(document.getElementById('endX').value));
          const endY = convertToMetric(parseFloat(document.getElementById('endY').value));
          const feedRate = parseFloat(document.getElementById('probeFeedRate').value);
          const retractHeight = convertToMetric(parseFloat(document.getElementById('retractHeight').value));
          const maxPlunge = convertToMetric(parseFloat(document.getElementById('maxPlunge').value));

          const spacingX = (endX - startX) / (cols - 1);
          const spacingY = (endY - startY) / (rows - 1);

          isProbing = true;
          stopProbing = false;

          document.getElementById('startProbeBtn').style.display = 'none';
          document.getElementById('stopProbeBtn').style.display = 'inline-block';
          document.getElementById('progressBarContainer').style.display = 'block';

          const totalPoints = rows * cols;
          let completedPoints = 0;
          const mesh = [];

          // Initialize mesh array
          for (let r = 0; r < rows; r++) {
            mesh[r] = [];
            for (let c = 0; c < cols; c++) {
              mesh[r][c] = { x: startX + c * spacingX, y: startY + r * spacingY, z: null };
            }
          }

          const updateProgress = (message) => {
            document.getElementById('probeStatus').textContent = message;
            document.getElementById('progressFill').style.width = (completedPoints / totalPoints * 100) + '%';
            document.getElementById('probeStats').textContent =
              'Completed: ' + completedPoints + ' / ' + totalPoints + ' points';
          };

          try {
            // Set absolute mode
            await sendCommand('G90');
            await new Promise(r => setTimeout(r, 100));

            // Probe each point
            for (let r = 0; r < rows && !stopProbing; r++) {
              for (let c = 0; c < cols && !stopProbing; c++) {
                const x = mesh[r][c].x;
                const y = mesh[r][c].y;

                updateProgress('Moving to point (' + (r+1) + ',' + (c+1) + ')...');

                // Move to XY position at safe height
                await sendCommand('G0 Z' + retractHeight.toFixed(3));
                await new Promise(r => setTimeout(r, 200));
                await sendCommand('G0 X' + x.toFixed(3) + ' Y' + y.toFixed(3));
                await new Promise(r => setTimeout(r, 500));

                updateProgress('Probing point (' + (r+1) + ',' + (c+1) + ')...');

                // Probe down
                const probeCmd = 'G38.2 Z-' + maxPlunge.toFixed(3) + ' F' + feedRate.toFixed(0);
                await sendCommand(probeCmd);

                // Wait for PRB response
                try {
                  const prbResponse = await waitForResponse(/\\[PRB:/, 15000);
                  const prb = parsePRB(prbResponse);

                  if (prb && prb.success) {
                    mesh[r][c].z = prb.z;
                    completedPoints++;
                  } else {
                    throw new Error('Probe did not contact surface');
                  }
                } catch (err) {
                  updateProgress('Error at point (' + (r+1) + ',' + (c+1) + '): ' + err.message);
                  stopProbing = true;
                  break;
                }

                // Retract
                await sendCommand('G0 Z' + retractHeight.toFixed(3));
                await new Promise(r => setTimeout(r, 200));
              }
            }

            if (!stopProbing && completedPoints === totalPoints) {
              meshData = {
                mesh,
                gridParams: { rows, cols, startX, startY, endX, endY, spacingX, spacingY }
              };

              // Save mesh to server
              await fetch(API_BASE + '/api/plugins/com.ncsender.3dmesh/settings', {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ meshData })
              });

              updateProgress('Probing complete! ' + totalPoints + ' points captured.');
              updateMeshStatus();
            } else if (stopProbing) {
              updateProgress('Probing stopped by user.');
            }
          } catch (error) {
            updateProgress('Error: ' + error.message);
          } finally {
            isProbing = false;
            document.getElementById('startProbeBtn').style.display = 'inline-block';
            document.getElementById('stopProbeBtn').style.display = 'none';
          }
        });

        // Stop probing
        document.getElementById('stopProbeBtn').addEventListener('click', async () => {
          stopProbing = true;
          await sendCommand('!'); // Feed hold
          await new Promise(r => setTimeout(r, 100));
          await sendCommand('\\x18'); // Soft reset
        });

        // Save mesh to file
        document.getElementById('saveMeshBtn').addEventListener('click', async () => {
          if (!meshData) return;
          try {
            await fetch(API_BASE + '/api/plugins/com.ncsender.3dmesh/settings', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ meshData, saveMeshFile: true })
            });
            alert('Mesh saved to file!');
          } catch (error) {
            alert('Failed to save mesh: ' + error.message);
          }
        });

        // Load mesh from file
        document.getElementById('loadMeshBtn').addEventListener('click', async () => {
          try {
            const response = await fetch(API_BASE + '/api/plugins/com.ncsender.3dmesh/settings');
            const settings = await response.json();
            if (settings.meshData) {
              meshData = settings.meshData;
              updateMeshStatus();
              alert('Mesh loaded!');
            } else {
              alert('No saved mesh found.');
            }
          } catch (error) {
            alert('Failed to load mesh: ' + error.message);
          }
        });

        // Clear mesh
        document.getElementById('clearMeshBtn').addEventListener('click', () => {
          if (confirm('Clear mesh data?')) {
            meshData = null;
            updateMeshStatus();
          }
        });

        // Apply compensation
        document.getElementById('applyCompensationBtn').addEventListener('click', async () => {
          if (!meshData) {
            alert('No mesh data available');
            return;
          }

          const referenceZ = convertToMetric(parseFloat(document.getElementById('referenceZ').value));

          try {
            // Save referenceZ and trigger compensation
            await fetch(API_BASE + '/api/plugins/com.ncsender.3dmesh/settings', {
              method: 'PUT',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ referenceZ, applyCompensation: true, meshData })
            });

            // The server will apply compensation and reload the file
            alert('Z compensation applied! Check the loaded G-code.');
            window.postMessage({ type: 'close-plugin-dialog' }, '*');
          } catch (error) {
            alert('Failed to apply compensation: ' + error.message);
          }
        });

        // Initialize
        updateMeshStatus();
      })();
    </script>
    `,
    { closable: true, width: '750px' }
  );
}

export async function onUnload(ctx) {
  ctx.log('3DMesh plugin unloaded');
}
